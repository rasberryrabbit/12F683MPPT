program _12F683MPPT;

{ 12F683 MPPT controller

  Copyright (C) 2015-2019 rasberryrabbit

  This source is free software; you can redistribute it and/or modify it under
  the terms of the GNU General Public License as published by the Free
  Software Foundation; either version 2 of the License, or MPL 1.1
  any later version.

  This code is distributed in the hope that it will be useful, but WITHOUT ANY
  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
  details.

  A copy of the GNU General Public License is available on the World Wide Web
  at <http://www.gnu.org/copyleft/gpl.html>. You can also obtain it by writing
  to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
  MA 02111-1307, USA.
}


{$define USE_EEPROM_LM358DIFF}
{$define Write_OPAMP_DIFF}

const
   PWM_MAX = 200;
   PWM_MIN = 10;
   PWM_START = PWM_MAX * 30 div 100;
   PWM_MID = PWM_MAX div 2-5;

   TMR1L_LOAD=$17;
   TMR1H_LOAD=$FC;                 // 1ms, 65535 - 1000

   VOLMUL = 4;                     // 25 div 6 <- 25V(1024) : 6A(1024), don't exceed 8
   //CURDIV = 2;
   _UPDATE_INT = 25;               // 25ms
   _PWM_CHECK = 4500;

   cLM358_diff = 0;
   adc_max_loop = 4;               // 8

label
   CONTLOOP;

var
   LED1:sbit at GP5_bit;
   Write_OPAMP : sbit at GP3_bit;
   // GP2 : PWM
   TICK_1000 : word;

   LED1_tm : word;
   prevtime, powertime, voltime, watchdog : word;
   adc_vol, adc_cur, vol_prev1, vol_prev2 : word;
   power_prev, power_curr : dword;
   i, LM358_diff, cPWM : byte;
   flag_inc : boolean;
   wtmp, xtmp : word;

procedure Interrupt(); iv 0x0004; ics ICS_AUTO;
begin
     if T1IF_bit=1 then begin
       TMR1H:=TMR1H_LOAD;
       TMR1L:=TMR1L_LOAD;
       T1IF_bit:=0;
       Inc(TICK_1000);
     end;
end;

procedure SetPWM(val:Byte);
begin
  CCPR1L:=val shr 1;
  DC1B1_bit:=val.0;
end;

function GetPWM():Byte;
begin
  Result:=CCPR1L shl 1;
  Result.0:=DC1B1_bit;
end;

function tick_diff(a, b: word):word;
begin
  if a<b then
    result:=a+(65535-b)+1
    else
      result:=a-b;
end;

begin
{$ifdef USE_8M}
     OSCCON:=%01110000;  // 8MHz
{$endif}
     CMCON0:=7;          // disable comparator
     ANSEL:=%00001001;   // AN0, AN3
     

     TRISIO0_bit:=1;      // AN0
     TRISIO4_bit:=1;      // AN3
     TRISIO1_bit:=1;      // VREF

     TRISIO5_bit:=0;      // LED
     VCFG_bit:=1;         // VREF
     //CHS1_bit:=1;
     ADFM_bit:=1;

     T2CON:=0;               // TMR2
     TRISIO2_bit:=1;
     PR2:=(PWM_MAX shr 1)-1; // PR2 * 2 = {CCPR1L, DC1B1}, ignore DC1B0
     DC1B0_bit:=0;
     CCP1CON:=%00001111;     // PWM active low
     SetPWM(0);
     TMR2IF_bit:=0;
     TMR2ON_bit:=1;
     ClrWDT;
     while TMR2IF_bit=0 do ;
     TRISIO2_bit:=0;      // PWM

     LED1:=0;
     LED1_tm:=200;
     TICK_1000:=0;

     LM358_diff:=cLM358_diff;
     Delay_100ms;
     Delay_100ms;
     ClrWDT;
     {$ifdef Write_OPAMP_DIFF}
     if Write_OPAMP=0 then begin
       Delay_100ms;
       Delay_100ms;
       adc_cur:=ADC_Read(0);
       EEPROM_Write(0, Lo(adc_cur));
       Delay_100ms;
       LED1:=1;
       Delay_ms(700);
       LED1:=0;
     end;
     ClrWDT;
     {$endif}

     {$ifdef USE_EEPROM_LM358DIFF}
     Delay_100ms;
     LM358_diff:=EEPROM_Read(0);
     {$endif}
     if LM358_diff>$1f then
       LM358_diff:=0;

     T1CKPS1_bit:=0;
{$ifdef USE_8M}
     T1CKPS0_bit:=1;               // timer prescaler 1:2
{$else}
     T1CKPS0_bit:=0;               // timer prescaler 1:1
{$endif}
     TMR1CS_bit:=0;
     TMR1L:=TMR1L_LOAD;
     TMR1H:=TMR1H_LOAD;
     T1IF_bit:=0;

     adc_vol:=0;
     adc_cur:=0;
     power_curr:=0;

     TMR1IE_bit:=1;
     PEIE_bit:=1;

     GIE_bit:=1;                   // enable Interrupt

     TMR1ON_bit:=1;

     SetPWM(PWM_START);
     flag_inc:=True;
     vol_prev1:=0;

     powertime:=0;
     prevtime:=0;
     voltime:=0;

     // starting LED
     delay_ms(300);
     LED1:=1;
     delay_ms(300);
     LED1:=0;
     clrwdt;
     watchdog:=0;

     while True do begin
       // LED
       wtmp := TICK_1000;
       if tick_diff(wtmp, prevtime) > LED1_tm then begin
         prevtime := wtmp;
         LED1 := not LED1;
       end;

       // save previous adc values
       vol_prev2:=vol_prev1;
       vol_prev1:=adc_vol;
       // Read Sync with PWM clock
       while TMR2IF_bit=0 do ;
       // adc read
       adc_cur:=ADC_Read(0);
       adc_vol:=ADC_Read(3);
       for i:=1 to adc_max_loop-1 do begin
         xtmp:=ADC_Read(0);
         wtmp:=ADC_Read(3);
         //adc_vol:=(adc_vol+wtmp) div 2;
         //adc_cur:=(adc_cur+xtmp) div 2;
         if xtmp < adc_cur then begin
           adc_cur:=xtmp;
           adc_vol:=wtmp;
         end;
       end;
       adc_vol:=adc_vol * VOLMUL;

       // clear watchdog
       wtmp:=TICK_1000;
       if tick_diff(wtmp,watchdog) > 1000 then begin
         watchdog:=wtmp;
         clrwdt;
       end;

       // check power
       wtmp:=TICK_1000;
       if tick_diff(wtmp,powertime) < _UPDATE_INT then
         continue;
       powertime:=wtmp;

       power_prev:= power_curr;
       power_curr:= dword(adc_vol * adc_cur);

       // led indicating and check low current
       if adc_cur>LM358_diff then begin
         // power check
         if power_curr = power_prev then begin
           LED1_tm:=500;
           continue;
         end else if power_curr < power_prev then begin
           LED1_tm:=300;
           flag_inc:=not flag_inc;
         end else begin
           LED1_tm:=300;
         end;

       end else begin
         LED1_tm:=200;
         SetPWM(PWM_START);
         flag_inc:=True;
         power_curr:=0;
         adc_cur:=0;
         continue;
       end;

       // set PWM value
       cPWM:=GetPWM();
       if flag_inc then begin
         if cPWM<PWM_MAX then begin
           Inc(cPWM);
           SetPWM(cPWM);
         end else begin
           SetPWM(PWM_MAX);
           flag_inc:=false;
         end;
       end else begin
         if cPWM>PWM_MIN then begin
           Dec(cPWM);
           SetPWM(cPWM);
         end else begin
           SetPWM(PWM_MIN);
           flag_inc:=true;
         end;
       end;
CONTLOOP:

     end;
end.